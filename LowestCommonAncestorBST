// Time complexity: O(N)
// Space Complexity: O(N)
// Using recursion
class Solution {
    class Solution {
        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
            if(p.val < root.val && q.val < root.val){
                return lowestCommonAncestor(root.left, p, q);
            }
            else if(p.val > root.val && q.val > root.val){
                return lowestCommonAncestor(root.right, p, q);
            }
            else {
                return root;
            }
        }
}

// Iterative Approach
// Time complexity: O(N)
// Space Complexity: O(N)
class Solution {
        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

                if( root == null) return root;
                while(root != null){
                    if(p.val < root.val && q.val < root.val){
                        root = root.left;
                    }
                    else if(p.val > root.val && q.val > root.val){
                        root = root.right;
                    }
                    else {
                        return root;
                    }
                }
                return null;
         }
    }

